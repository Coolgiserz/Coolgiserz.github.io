[{"authors":null,"categories":null,"content":"爱好金庸小说的程序员\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://coolgiserz.github.io/author/coolcats/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/coolcats/","section":"authors","summary":"爱好金庸小说的程序员","tags":null,"title":"CoolCats","type":"authors"},{"authors":["吳恩達"],"categories":null,"content":"吳恩達 is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed neque elit, tristique placerat feugiat ac, facilisis vitae arcu. Proin eget egestas augue. Praesent ut sem nec arcu pellentesque aliquet. Duis dapibus diam vel metus tempus vulputate.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"da99cb196019cc5857b9b3e950397ca9","permalink":"https://coolgiserz.github.io/author/%E5%90%B3%E6%81%A9%E9%81%94/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/%E5%90%B3%E6%81%A9%E9%81%94/","section":"authors","summary":"吳恩達 is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.","tags":null,"title":"吳恩達","type":"authors"},{"authors":[],"categories":[],"content":"Free and open source GIS in South America: political inroads and local advocacy ","date":1607608697,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607608697,"objectID":"0016891c7289b3c310d0931cd358df14","permalink":"https://coolgiserz.github.io/publication/free-and-open-source-gis-in-south-america/","publishdate":"2020-12-10T21:58:17+08:00","relpermalink":"/publication/free-and-open-source-gis-in-south-america/","section":"publication","summary":" 全世界的地理信息系统从业人员享有越来越多的免费和开源软件（FOSS)选择。这种软件扩大了地理信息系统在经济发展中国家的使用范围，同时促进了当地技术专长的发展。本文回顾了南美洲对FOSS GIS的吸收和宣传，特别是它与该地区对自由和开放源码软件的政治友好气氛的关系。在南美洲面向公众的网络地图中评估了自由和开放源码软件GIS的使用与否，首先是在国家政府一级，然后是以阿根廷为研究对象的省一级。然后总结了南美洲围绕FOSS GIS的地方技术支持小组和软件开发方案。最后，介绍了在地方一级建立FOSS GIS技术社区的三个案例研究：FOSSGIS Brasil在线杂志、Geoinquietos Argentina professional network（地理信息学阿根廷职业网络）和巴西的FOSS.4GIS.GOV会议。对这些团体的领导人、动态和做法的研究，可以为世界各地处于类似情况下的为促进FOSS GIS的采用、发展、技能和服务而努力的其他团体提供参考。","tags":[],"title":"「论文阅读」-南美洲的免费和开放源码地理信息系统：政治进展和地方宣传","type":"publication"},{"authors":[],"categories":[],"content":"","date":1607604211,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607604211,"objectID":"d0be192c03281ea1875633715848a2f0","permalink":"https://coolgiserz.github.io/post/attention-mechanism/","publishdate":"2020-12-10T20:43:31+08:00","relpermalink":"/post/attention-mechanism/","section":"post","summary":"","tags":[],"title":"Attention Mechanism","type":"post"},{"authors":["CoolCats"],"categories":["通勤流预测","嵌入学习","AAAI"],"content":"Learning Geo-Contextual Embeddings for Commuting Flow Prediction 0x00 引言 本文章题为“用于通勤流预测的地理上下文嵌入学习”。\n关键几个问题：\n 什么是通勤流？ 什么是地理上下文？ 如何对地理上下文信息进行嵌入学习？ 该方法工作效果如何？存在什么缺陷吗？  通勤流 什么是通勤流？ 通勤是一种从家到工作地的往返过程。日复一日的通勤行为形成了一个与社会经济因素密切关联的复杂网络。\n通勤流也被看作城市规划中的一个基本问题，因为其揭示了城市中劳动力供给与需求之间的空间关系。所以从城市规划的角度来看，有必要研究基础设施和土地利用对通勤流的影响。\n通勤流 通勤流预测与交通流预测有何区别？ 说的通勤流预测可能又容易联想到交通流预测，两者有什么区别呢？\n交通流预测是一个时序预测问题，在技术实现上需要将历史轨迹信息作为输入特征；而通勤流预测旨在揭示城市中劳动力供给侧与需求侧之间的空间关系，通常是只用节点属性信息（基建、土地利用）预测的是边级别的信号（如通勤流的大小）。\n0x01 相关工作 通勤流相关工作 针对通勤流预测问题，人们以前有用重力模型、非参数模型、介入机会模型。\n然而：\n(1) 重力模型只是简单地将物理定律搬过来，实际上不能很好地刻画复杂的通勤模式，应用效果不理想。\n(2) 现有的大多数机器学习模型只用OD点的节点属性特征，忽略了区域之间的空间依赖性\n介入机会模型倒是考虑了出发地、目的地周边对中心的影响，本文提出的地理上下文嵌入便受到这类方法的启发。\n图表征相关工作 图表征学习方面也有很多利用节点属性、节点邻域信息的方法，本文方法主要受GAT的影响，将自注意力机制引入到通勤流预测上，捕获地理上下文信息。\n0x02 本文观点 至此本文方法的基本框架已经出来了。\n 针对通勤网络 通过地理上下文嵌入学习地理单元及其上下文信息，通过多任务预测损失函数约束嵌入向量中的信息更适合进行通勤流预测。所谓的地理上下文信息就是指地理单元周围的POI、土地利用等信息，抽象来说就是邻域节点的属性。  GMEL\n用GAT将地理上下文信息编码到嵌入空间中 这里要注意的是文章提出用2个GAT分别建模出发地和目的地的特征，即要把劳动供给侧和需求侧的特征进行解耦。\n然后通过多任务学习框架约束嵌入向量更适应于流预测表示。\n通过多任务学习框架约束嵌入向量更适应于通勤流预测 主任务自然是通勤流预测，子任务是预测两个地理单元（出发地和目的地）的流入/流出量，这背后的直觉是通勤流与地理单元的流入/流出量之间高度相关，引入这两个子任务可以约束嵌入向量包含更多有助于通勤流预测的信息（监督信号）。\n基于GMEL和多任务学习框架的通勤流预测 前面基于GMEL可以获得地理单元的嵌入向量，基于这些向量在训练一个回归学习器（如梯度提升树、随机森林）便能进行通勤流预测。算法如下：\n 端到端地训练一个GMEL（预训练过程） 基于嵌入向量再训练一个流预测模型  训练算法 0x03 实验 实验部分需要验证的点包括：\n 地理上下文信息是否真的有助于通勤流预测？ 使用两个GAT分别建模供给特征和需求特征是多此一举吗？ 有必要引入多任务学习框架吗？  实验环境 用到了通勤流、土地利用的数据集和距离计算的包。\n实验结果 观察实验结果可发现：\n 所有GMEL系列的模型都比基准模型要好，表明地理上下文信息有助于通勤流来说 标准的GMEL比另外两个变种表现好，验证了多任务学习框架的有效性和对供需特征解耦的必要性  测试表现 参数敏感性分析 、残差分析也表明方法的鲁棒性。\n残差分析 0x04 结论 总结全文，文章提出利用地理上下文信息预测通勤流，并提出一个嵌入学习框架来学习地理单元的上下文信息，结果表明引入这种信息是有助于通勤流预测的。\n","date":1607516303,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1607516303,"objectID":"b1e542f793e69f4070bf089691ac791a","permalink":"https://coolgiserz.github.io/publication/learning-geo-embeding-for-commute-flow-prediction/","publishdate":"2020-12-09T20:18:23+08:00","relpermalink":"/publication/learning-geo-embeding-for-commute-flow-prediction/","section":"publication","summary":"根据基础设施和土地使用信息预测通勤流量对于城市规划和公共政治发展至关重要。然而，由于通勤流的复杂模式，这是一项具有挑战性的任务。传统的模型，如重力模型，主要是从物理学原理中得出的，在现实世界中需要考虑很多因素的情况下，其预测能力有限。同时，现有大多数机器学习的方法忽略了空间相关性，没有对区域间的依赖关系进行建模。为了解决这些问题，我们提出了Geo-contextual Multitask Embedding Learner(GMEL)，一个从地理上下文信息中捕捉空间相关性的模型，用于通勤流量预测。具体来说，我们首先构建了一个包含地理上下文信息的地理适应性网络。然后，提出了一种基于图注意力网络（GAT）框架的注意力机制，以捕捉空间相关性，并将地理环境信息编码到嵌入空间。两种不同的GAT分别用来模拟供给和需求的特征。 为了提高嵌入表示的有效性，多任务学习框架用于引入更强的限制，迫使嵌入封装- sulate流量预测的有效表示。最后，基于学习到的EM- beddings训练梯度提升机来预测换乘流量。我们使用纽约市的真实世界数据集来评估我们的模型，经验-心理结果证明了我们所提出的方法与现有技术的有效性。","tags":["嵌入学习"],"title":"「论文阅读」-学习用于通勤流嵌入的地理上下文嵌入","type":"publication"},{"authors":["CoolCats"],"categories":["资源"],"content":"编程||软件开发 论坛  stackoverflow  练习平台  Code Jam tutsplus sitepoint Leetcode  工具  tortoisegit：https://tortoisegit.org/ 数据字典工具：https://dbmstools.com/data-dictionary-tools DBeaver Mock data generator：https://github.com/dbeaver/dbeaver/wiki/Mock-Data-Generation-in-DBeaver  问卷调研  问卷星：https://www.wjx.cn/newwjx/manage/myquestionnaires.aspx  需求分析   Mindmaps：https://www.mindmapping.com/\n  mindmaps：https://www.mindmaps.app/ Github开源，基于HTML5，Js，Css。项目地址：https://github.com/drichard/mindmaps\n  Mindmap： chrome扩展\n  Coggle: 实时协作\n  FreeMind：https://sourceforge.net/projects/freemind/files/latest/download 免费思维导图软件，由Java编写\n  XMinds:https://www.xminds.com/\n  架构设计  Visio：https://products.office.com/zh-cn/visio/flowchart-software plantuml：http://plantuml.com/zh/class-diagram Edraw：https://www.edrawsoft.cn/ Rational Rose：  协作工具   Github：https://github.com/ 共同开发，分布式版本控制\n  SVN：https://tortoisesvn.net/\n  OneNote：http://www.onenote.com/download/\n  Teamviewer：https://www.teamviewer.com/cn/ 多人会议\n  集成开发环境||编辑器   Atom：https://atom.io/ Github推出的跨平台文本编辑器\n  Netbeans：https://netbeans.org/ 开源Java IDE。可扩展于PHP、C++等语言开发\n  Pycharm：https://www.jetbrains.com/pycharm/ JetBrains推出的Python开发环境\n  IntelliJ IDEA：https://www.jetbrains.com/idea/ JetBrains推出的Java开发环境\n  Eclipse：https://download.eclipse.org/ 基于Java的可扩展开发平台，通过插件组件构建开发环境\n  Code::Blocks：https://www.codeblocks.org/ 开源全功能C++开发环境，使用wxWidgets图形界面库，由C++语言开发完成\n  Aptana Studio 3：https://www.aptana.com/ 开源Ajax开发环境\n  CLion：https://www.jetbrains.com/clion Jetbrains推出的C++开发环境\n  CodeLite:https://codelite.org 开源，C/C++编程语言的跨平台IDE\n  Komodo:https://www.activestate.com/products/komodo-ide/\n  Xcode:https://developer.apple.com/xcode/\n  Visual Studio：\n  Sublime：http://www.sublimetext.com/\n  模拟  夜神模拟器：https://www.yeshen.com/ Easy-Mock：https://easy-mock.com/  库   ms4w：https://ms4w.com/ MapServer for Windows\n  angular：https://angularjs.org/\n  JQuery：http://jquery.com/\n  React：https://reactjs.org/ js构建用户界面\n  jQuery插件：http://plugins.jquery.com/\n  wxwidgets：https://www.wxwidgets.org/ 轻量级C++ GUI库\n  学习资源  Javascript：https://github.com/jobbole/awesome-python-books  云平台  LeanCloud：https://leancloud.cn/ Google Earth Engine：https://earthengine.google.com/  设计 原型设计   ProcessOn：https://www.processon.com/diagrams 团队协作、流图绘制\n  Mockingbird：https://gomockingbird.com/home 在线原型设计平台\n  Gliffy：https://www.gliffy.com/\n  Drawanywhere：http://www.drawanywhere.com/\n  Sketch：http://www.sketchcn.com/ Mac用草图软件\n  图标生成\u0026amp;\u0026amp;下载   Easyicon：https://www.easyicon.net/\n  iconbench：http://iconbench.com/\n  Fontello：http://fontello.com/\n  icondeposit：https://www.icondeposit.com/\n  iconarchive：http://www.iconarchive.com/\n  Flaticon：https://www.flaticon.com/\n  Logo设计  logospire：http://logospire.com/  壁纸  wallpaperscraft：https://wallpaperscraft.com/  可视化  processing：https://processing.org/ Dionysus：https://www.mrzv.org/software/dionysus/ apophysis：http://www.apophysis.org/downloads.html guihi：http://gudhi.gforge.inria.fr/python/latest/ d3.js：https://d3js.org pyechart：https://pyecharts.org/#/zh-cn/global_options?id=legendopts：图例配置项  信息安全 C\u0026amp;C 网络流量 whonix：https://www.whonix.org/\n其他电脑工具 下载工具  IDM：http://www.internetdownloadmanager.com/  数学  MIT Gibert-Strang：http://www-math.mit.edu/~gs/  GIS二次开发 Python  pywin32：https://github.com/mhammond/pywin32  Github Tools Summary  伯乐在线整理：https://github.com/jobbole/  论文 论文查重  http://www.cnkicheck.info/  学习资源  Git分支：https://learngitbranching.js.org/ 图解Git：https://marklodato.github.io/visual-git-guide/index-zh-cn.html GoogleBlog：https://ai.googleblog.com/ Wavelab_850：http://statweb.stanford.edu/~wavelab/Wavelab_850/download.html  ","date":1555773945,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1555773945,"objectID":"c72f284aa80c75608ecec300eb786919","permalink":"https://coolgiserz.github.io/post/useful-resources/","publishdate":"2019-04-20T23:25:45+08:00","relpermalink":"/post/useful-resources/","section":"post","summary":"编程、软件、设计等工具","tags":["资源","书签"],"title":"各类有用书签资源汇总","type":"post"},{"authors":[],"categories":[],"content":"论文查阅系统：\n CSU Web Of Science ScienceDirect 万方数据资源系统 维普中文期刊 IEEE  Keywords  环境（退化/保护）成本 环境会计 环境成本计算 （虚拟/实际）治理成本 生态系统管理/服务 生态系统服务功能 生态系统服务价值 土地开发项目 生态系统价值计算 价值评估 绿色经济核算 绿色发展（实践/框架） 生物物理量化 生物圈 生物多样性   主题 环境退化的代价？\n 生态功能的持续性利益建模  效益  供应  食物供应 植物授粉   调节  植物碳固定——能值法？ 水（自净、防洪等）——以人类基础设施替代（如净水设施、防洪设施等） 生物多样性——难点   文化  精神 宗教     考虑  定义生态系统服务 等效替代 水环境退化成本——人工水污染治理花费（查数据）+生物多样性损失建模（？） 森林退化——空气污染治理成本      Tasks  建立一个生态服务估值模型 用模型评价不同规模的土地利用项目的成本规模效益分析 基于以上分析模型设计评估模型的有效性 模型对于土地利用项目规划者和管理者有何启示？ 模型随着时间变化需要作出怎样的修改？  Existing Mathods  NPP(net primary production) 元分析   References An ecological perspective on the valuation of ecosystem services The value of the world’s ecosystem services and natural capital [paper] Valuing ecosystem services: A shadow price for net primary production：http://sites.bu.edu/cliveg/files/2013/12/arr01.pdf 从两个问题出发：生态系统服务对于传统指标如GDP度量的经济是否有贡献？这种贡献能否被用作隐式的价格来进行计算？ net primary production\n 相关因素  碳固定 蒸腾作用 土地腐蚀（负相关） 生物量   直接 间接 文化（旅行费用法，享乐价格）  计算方法   The history of ecosystem services in economic theory and practice: From early notions to markets and payment schemes Valuing a diversity of ecosystem services: The way forward to protects trategic groundwater resources for the future? [link]\nData Sources  https://www.weather.gov/dmx/ 美国国家海洋和大气管理局 Penn_World_Table ScienceBase [link] US Landcover [link] Bison Web 美国鱼类栖息地退化图 美国生态系统恢复的经济影响 水资源普查 欧洲 Emerge-nead IPCC IPCC数据分发中心 NEAD [link] 欧洲疾病预防控制中心 欧洲环境代理 美国国家能源数据系统 电力数据浏览器 NREL美国各州太阳能数据 美国劳动力数据 美国劳工统计局 Economic Research Gloåbal Economic EmergyDatabase： [link1] [link2] 美国人口普查局 国家管道测绘系统 NAICS 美国各州劳动力统计表 排放和发电资源综合数据库 德克萨斯州全州图像和GIS数据 卡尔加里大学图书馆（GIS资源） 佛罗里达环境保护部 美国城市开放数据普查 OpenData_CityOfNetwork PURDUE图书馆 The Nature Con Map of Life 气候数据图 EPA  Baike   旅行费用法\n  生物量： [link1] [link2]\n  初级生产   Cobb-Douglas生产函数及其优缺点: [link1] [link2] [link3]\n  PWT   元分析：https://zh.wikipedia.org/wiki/%E5%85%83%E5%88%86%E6%9E%90\n  影子价格 [link1] [link2] [link3]   生态服务价值   环境成本分类   生态系统服务分类\n  能值法指数解释\n  土地利用规划\n  中国森林生态系统\n  土地使用规划\n  ArcGIS交集制表\n  美国风能资源\n  劳动力参与率\n  固定资产投资\n  matlab字符串处理函数\n  Matlab File Exchange\n  BEA in the classroom\n  面板数据分析\n  非货币生态系统核算体系   国际统一阶段代码 https://www.iso.org/stage-codes.html#50.20\n  国际标准组织污染、污染控制 https://www.iso.org/ics/13.020.40/x/\n  温室气体协议 https://ghgprotocol.org/\n  组织的温室气体排放量化和报告规范及指南\n  能值和变革 http://www.emergysociety.com/emergy-and-transformity/\n  python excel https://zhuanlan.zhihu.com/p/23998083\n  加州内化达Public Viewer https://pvnpms.phmsa.dot.gov/PublicViewer/\n  国家空气毒物评估 https://www.epa.gov/national-air-toxics-assessment\n  2014 National Air Toxics Assessment https://gispub.epa.gov/NATA/\n  成本效益分析 https://www.britannica.com/topic/cost-benefit-analysis\n  statisca统计门户网站 https://www.statista.com/topics/2582/subway/\n  斯坦福确定项目成本与效益\n  plannerWeb：http://plannersweb.com/2013/12/pro-forma-101-what-will-it-cost/\n  Agent-based Model   clarkLab https://clarklabs.org/ https://en.wikipedia.org/wiki/TerrSet\n  美国土地利用\n  IDRISI part1 part2 part3\n  时间序列平稳性\n  清洁空气法文本\n  us air quality standard\n  Considerations  一个真实的土地利用项目考虑上生态因素后的真实经济成本是？   大型  全国铁路网建设 全国管网 水坝   小型  元胞自动机多智能体模拟？ 植被面积变化、水文条件可能发生变化、空气可能会有污染（旧式火车）等等。缓冲区分析？    ","date":1548774155,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548774155,"objectID":"39c9cc8a5da040968cbaf42dfb657aaf","permalink":"https://coolgiserz.github.io/post/icm-2019/","publishdate":"2019-01-29T23:02:35+08:00","relpermalink":"/post/icm-2019/","section":"post","summary":"美国大学生数学建模竞赛2019问题E资料小结","tags":[],"title":"MCM/ICM 2019 Problem E","type":"post"},{"authors":[],"categories":[],"content":"哈夫曼树 哈夫曼树特点 哈夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。常可用作无损压缩。\n 每个结点只有0或2各子节点 同一组权值得到的哈夫曼树可能不唯一 权值越大的结点越靠近哈夫曼树的根节点，权值越小的结点越原理哈夫曼树的根节点 一棵有n各叶子结点的哈夫曼树共有2n-1个结点 带权值的结点都是叶子结点，不带权值的结点都有子结点  哈夫曼树构建 此处把哈夫曼树构建过程分为2个步骤：数据组织、构建树\n数据组织 数据组织包括对原始数据的预处理，如原始数据是一段字符串，考虑使用什么数据结构对字符串中的字符及其发生频率进行组织，发生频率越高的字符认为其权重越大，于是对其“特殊照顾”。如使用链表或数组组织每个字符，每个节点的数据结构可如下：\npackage com.coolcats.tree; /** * 哈夫曼树二叉树节点 * @author CoolCats */ public class Node { public Node left,right;//左子节点 public int weight; //右子节点 public String data; // 数 据 public Node() { } public Node(String data,int weight) { this.data = data; this.weight = weight; } public String toString() { return this.data+\u0026quot;:\u0026quot;+this.weight; } }  而后对节点列表按照其权重大小进行排序，不失一般性，此处升序排序:\n/** * 列表排序 * * @param list */ private void sortList(ArrayList\u0026lt;Node\u0026gt; list) { Node minNode = null; Node jNode = null; for (int i = 0; i \u0026lt; list.size() - 1; i++) { int min = i; for (int j = i + 1; j \u0026lt; list.size(); j++) { minNode = list.get(min); jNode = list.get(j); if (minNode.weight \u0026gt; jNode.weight) { min = j; } } if (min != i) { Node tmpNode = list.get(i); list.set(i, list.get(min)); list.set(min, tmpNode); } } }  构建树 得到了排序后的列表后，就可以构建树了，由于哈夫曼树的特点，小权值的节点尽可能远离根节点、大权值的节点尽可能靠近根节点，并且无法预估根节点到底在什么高度上，所以只能采用自底向上的方式构建哈夫曼树。具体步骤为\n 输入排序后的列表， 判断列表个数是否大于1，如果是，从中取出最小的两个元素，构造父节点，如果否，跳到4 将父节点添加到列表中，对列表重新排序，回到2 将列表中最后一个元素作为哈夫曼树根节点 如此便可得到哈夫曼树  哈夫曼压缩 所谓哈夫曼压缩，就是利用哈夫曼树的性质实现对文件的无损压缩。 通常来说，数据在计算机中的存储按字节来计算，一个ascii码字符占一个字节，一个汉字字符占2个字节，这种每个字符都通过相同来表达的编码形式称为定长编码。而哈夫曼压缩就是通过变长编码的方式实现对文件的压缩，其思想是根据字符出现的概率来确定编码的长度，出现概率大的字符采用较短的编码来存储，出现概率小的字符采用较长的编码来存储。\n哈夫曼压缩实现 对于哈夫曼压缩可靠性而言最关键的保证是：任何一个字符的编码前缀都不能是另一个字符的编码。如果将一个节点到其左节点的路径标记为0，到其右节点的路径标记为1，那么，从根节点到每一个叶子节点所得到的哈夫曼编码是唯一的，且任一哈夫曼编码不是其他编码的前缀，满足条件。因此，实现压缩功能只要计算出每个字符的哈夫曼编码即可。在遍历哈夫曼树的同时计算哈夫曼编码的代码如下：\n/** * 后序遍历的同时标记每个节点的哈夫曼编码 * * @param root * @param code */ private void postOrder(Node root, String code) { if (root.left != null) // 左路径标记为0 postOrder(root.left, code + \u0026quot;0\u0026quot;); if (root.right != null) { // 右路径标记为1 postOrder(root.right, code + \u0026quot;1\u0026quot;); } // 输出哈夫曼树叶子节点编码 if (root.left == null \u0026amp;\u0026amp; root.right == null) { System.out.println(root.data + \u0026quot;\u0026lt;\u0026gt;\u0026quot; + code); // 将各个字符的哈夫曼编码存储 map.put(root.data, code); map1.put(code, root.data); } }  于是，在存储一个字符串时，只需要遍历这个字符串，取出每个字符对应的哈夫曼编码，每8位作为一个字节存储到文件中即可实现压缩，但要注意，哈夫曼编码的组合并不一定是8的整数倍，这可以通过“补0”来解决，所以存储压缩文件的时候还要把补0的个数记下，以便解压缩。一个demo版的代码如下：\n/** * 根据给定的路径以及哈夫曼编码将哈夫曼码存进相应的文件中 要存入压缩文件的信息，补了多少个0 * （demo版，效率较低） * @param path 压缩文件的路径 * @param code 哈夫曼编码 */ private void hfcode2file(String path, String code) { int len = code.length(); System.out.println(\u0026quot;哈夫曼编码长度：\u0026quot; + len); int comple = 8 - len % 8; if (comple \u0026lt; 8) { for (int i = 0; i \u0026lt; comple; i++) { code = code + \u0026quot;0\u0026quot;; } } OutputStream out = null; DataOutputStream dout = null; File file = new File(path); try { out = new FileOutputStream(file); dout = new DataOutputStream(out); int count = (len + comple) / 8; byte[] b = code.getBytes(); dout.writeInt(comple); dout.write(b); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { try { out.close(); dout.close(); } catch (IOException e) { e.printStackTrace(); } System.out.println(\u0026quot;压缩文件完成\u0026quot;); } }  解压缩就是根据读取文件的位，每读到一个哈夫曼编码（使用哈希表，判断是否存在对应的key）就返回其对应的字符，一直到文件末尾。\n/** * 解压缩 * @param path * @return */ private String file2hfcode(String path) { String code = null; InputStream in = null; DataInputStream din = null; int comple; File file = new File(path); try { in = new FileInputStream(file); din = new DataInputStream(in); comple = din.readInt(); byte[] bb = new byte[1024]; int res = din.read(bb); code = hfcode2String(bb,res,comple); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return code; }  问题思考  哈夫曼树的压缩效率如何？ 哈夫曼树压缩在什么场景下不适用？ 考虑包含中文等非英文国家字符的文件压缩应该如何实现？ 字典压缩（LZ77，LZ88，LZW等）  参考文献 哈夫曼编码维基百科\nLZW编码维基百科\nLZW压缩算法\n","date":1545231346,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1544453746,"objectID":"7d379e6f4158492f1588c3d8d093c088","permalink":"https://coolgiserz.github.io/post/hftree-datastructure/","publishdate":"2018-12-19T22:55:46+08:00","relpermalink":"/post/hftree-datastructure/","section":"post","summary":"哈夫曼编码——无损数据压缩的熵编码算法","tags":[],"title":"哈夫曼编码及其实现","type":"post"},{"authors":[],"categories":["OOP"],"content":"0x00 概念 首先区分两个概念：关键字和保留字。关键字指事先定义的，用来表示一种数据类型或者程序结构的对于编译器有特殊意义的“字符串”。而保留字则是预留的关键字，即现在还没有用到，但以后可能会作为关键字被使用。 所以，认识关键字与保留字的一个基本的作用，起码就在于为变量命名时不至于与关键字冲突、或者与“未来的关键字”冲突（如果使用了关键字、保留字作为变量命名，比较智能的IDE是会报错的，但如果用记事本或者在线刷题那就不一定有这么好的福利了）。当然，要真正使程序高效、健壮，那就要深刻认识各个关键字的内在含义。\n0x01 关键字总览 目前而言，Java的关键字有50个，还有一些保留字。其中保留字包括：goto、const，这是C++中的关键字。而关键字可大致分为9类。清单如下：\n 包相关（2个）：import、package 访问控制相关（3个）：public、protected、private 类、接口、抽象类、对象相关（6个）：class、interface、abstract、implements、extends、new 数据类型相关（9个）：void、short、int、long、float、double、byte、char、boolean、null 异常处理相关（5个）：try、catch、finally、throw、throws 程序控制结构相关（13个）：if、else、switch、case、break、default、for、continue、while、do、return、instanceof 修饰类、方法、属性、变量相关（7个）：static、final、native、synchronized、transient、volatile、strictfp 变量引用相关（2个）：super、this 其他（2个）：assert、enum  0x02 包相关 类似于C++中的命名空间，java提供了包机制用于区分不同组织、个人所编写的类，有效防止命名冲突，方便共享java程序。\n  package关键字 声明编译单元属于某个类库。如果使用package语句，它必须是文件中除了注释以外的第一行语句。\n  import关键字 导入包。\n  0x03 访问控制相关 对于java而言，访问控制权限可分为：public、protected、默认的、private，上述四种访问权限的大小排序是从大到小的，其中默认访问控制权限没有关键字。\n  public 接口访问权限\n  protected 继承访问权限\n  private 私有的\n  0x04类、接口、抽象类、对象相关   class 定义类的关键字\n  interface 定义接口的关键字。\n  abstract class 定义抽象类的关键字\n  extends 继承类或接口的关键字。类继承类，接口继承接口\n  implements 实现接口的关键字。一个类实现了某个接口就必须要实现该接口下的所有方法。\n  new 实例化对象。java完全采用了动态分配配内存的方式，即使用new关键字来动态创建对象实例，当对象不再被使用时，由垃圾回收器（GC）自动销毁对象，释放其占用的内存空间。\n  null 表示空对象。\n  0x04 数据类型相关   void 空返回类型，用于修饰函数。\n  byte 字节类型，占8 bit。因java中byte类型默认是带符号的，所以其范围为-2^7~2^7-1，即-128~127。 直接对两个byte类型的变量进行相加，其会自动转型为int，要对其进行强制转型。\n  short 短整型，占16 bit。范围-2^15~2^15-1。即Short.MIN_VALUE~Short.MAX_VALUE。\n  int 整型，占32 bit。范围-2^31~2^31-1。\n  long 长整型，占64 bit。范围-2^63~2^63-1。尽管long的范围已经比较大了，但要求如斐波那契数列数值时，还是很容易失效，比如要求斐波那契数列第一百个数，就超出了long类型所能表示的范围，此时考虑使用大整数，java中提供了BigInteger类型。\n  float 浮点型，占32 bit。\n  double 双精度型，占64 bit。java中double和float都是以科学计数法的方式进行表示。\n  char 字符型，16 bit。\n  boolean 布尔类型，取值true or false。\n  0x05 异常处理相关   try 捕获异常。 包含可能发生异常的语句块。\n  catch 处理异常。包含对异常的处理，一般用于提示开发者代码中不对劲的地方。\n  finally 指定不管是否发生异常都要执行的语句块。\n  throw 抛出异常对象。\n  throws 声明一个方法可能会抛出某种异常。（抛给调用该方法的地方）\n  0x06 程序控制结构相关 if、else、switch、case、break、default、for、continue、while、do、return、instanceof\n0x07 修饰类、方法、属性、变量相关   final final表示最终的，其用于修饰的对象都不可更改。final可修饰的内容包括：\n 类 用final修饰的类不可被继承。 普通方法 用final修饰ide普通方法不可被重写。（构造方法本身就不可被重写） 属性、变量、常量、形参 不可被改变。当final修饰基本类型时，参数值在方法体中不可被改变；修饰引用类型时，参数变量所引用的对象也不可改变。    static 一般来说，在创建类时，就是在描述那个类ide对象的外观和行为，在使用new创建对象之前，实际上并没有获得任何对象，只有当执行new之后，对象的数据存储空间才被分配，才可以被外界所调用。但如果希望特定的域不与类的任何对象关联在一起，即不创建对象也能够调用该方法，就可以考虑使用static关键字来修饰特定的域。 当使用static关键字声明某个属性或方法时，就意味着这个域或者方法不会与包含它的那个类的任何对象实例关联在一起。用static修饰的域或者变量存储在静态存储区域，在类被创建时优先被加载到内存中。 static可以修饰的内容包括\n 属性 常量 内部类 普通方法 要注意，static不能修饰构造方法。 代码块 用static修饰的代码块优先与构造方法执行    native 用于扩展java程序的功能，告知JVM该方法在外部定义，一般配合。java在运行速度上比C++要慢，对访问操作系统底层的支持也不够好，因此可使用native声明某些方法是由其他语言实现的（如C++）。\n  volatile 数据同步。\n  synchronized 针对代码块的同步锁\n  transient 瞬时的。\n  strictfp 可用于类、接口或方法。使用strictfp关键字声明一个方法时，该方法中所有的float和double表达式都严格遵守FP-strict的限制，符合IEEE-754规范。\n  0x09 变量引用相关   super 用于表示基类对象。\n  this 用于表示当前对象。\n  0x10 其他关键字   assert 断言，在代码中捕捉一些假设，看我们的假设是否成立，如果假设不成立，即断言中的布尔表达式为false，则会停止运行程序，抛出AssertionError错误（前提是要先支持断言），断言也可看作是更高级的异常捕获，主要在于它引入了程序猿的先验。Eclipse、MyEclipse中默认关闭断言，可在偏好设置中修改VM参数进行开启。\n  enum 枚举。\n  0x11 问题   内部类\n  GC需要解决的问题：\n（1） 哪些对象需要被回收？\n（2） 何时回收这些对象？\n（3） 如何回收这些对象？\n  ","date":1542987065,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1542987065,"objectID":"6cfc4dc2a70eb2a0725e331cfe40a3a6","permalink":"https://coolgiserz.github.io/post/java-keywords-summary/","publishdate":"2018-11-23T23:31:05+08:00","relpermalink":"/post/java-keywords-summary/","section":"post","summary":"关键字的前世今生","tags":["关键字"],"title":"Java关键字相关知识点总结","type":"post"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"6d99026b9e19e4fa43d5aadf147c7176","permalink":"https://coolgiserz.github.io/contact/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/contact/","section":"","summary":"","tags":null,"title":"","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"c1d17ff2b20dca0ad6653a3161942b64","permalink":"https://coolgiserz.github.io/people/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/people/","section":"","summary":"","tags":null,"title":"","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"e26a326b781f30bad2d960ba8592d05b","permalink":"https://coolgiserz.github.io/slides/geo-embedding-for-commuting-flow-prediction/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/slides/geo-embedding-for-commuting-flow-prediction/","section":"slides","summary":"","tags":null,"title":"","type":"slides"}]